# myex
강의자료, 책 등에서의 실습예제 나만의 방식으로 해본 것들


# GradeManagementSystem(학점관리시스템)
- 책 <Do it! 자바 프로그래밍 입문>의 최종 프로젝트 실습
- 데이터와 목표만 가지고 직접 설계 및 구현한 프로그램(책의 코드와 다름)
- Student 클래스 : 학생에 관한 클래스
  - 필드: 이름, 학번, 전공, 평균 점수, 최종 학점, 수강 과목(해시맵)
  - 생성자: 이름과 전공을 입력해야하고 학번은 자동으로 생성되며 수강과목 해시맵이 생성됨
  - 메서드: 평균 점수 집계, 최종 학접 집계, 수강과목 추가, 수강과목 점수 추가, 자동 학번 부여 등
- Major 클래스 : 전공에 관한 클래스
  - 필드: 전공명, 전공번호, 필수 수강과목
  - 생성자: 전공명과 필수 수강과목을 입력해야하고 전공번호는 자동 부여됨
  - 메서드: 전공명 getter, 전공번호 getter 필수 수강과목 getter 등
- Subject 클래스 : 강의 과목에 관한 클래스
  - 필드: 과목명, 과목번호, Pass/Fail 여부
  - 생성자: 과목명을 입력해야 하고 과목번호는 자동 생성됨
  - 메서드 : 과목명 getter, Pass/Fail 여부 setter 등
- Course 클래스 : 수강한 과목에 관한 속성 및 기능을 넣은 클래스
  - 필드: 과목, 점수, 학점, 학점 정책
  - 생성자: 과목을 입력해야 하며 점수는 -1(미입력)로 초기화됨
  - 메서드 : 학점 정책 setter(Pass/Fail여부-필수 수강과목 여부 확인 후 아니면 일반 학점 정책 적용), 점수 setter(점수가 입력되면 학점도 집계되도록 함) 등
- GradeSystem 인터페이스 : 학점을 산출하는 추상 메서드만 있는 학점 정책 인터페이스
  - General 구현 클래스 : 싱글톤 패턴의 일반 학점 정책
    - 오버라이딩한 String getGrade(int 점수)만 입력
  - ForRequiredSubject 구현 클래스 : 싱글톤 패턴의 필수과목 학점 정책
    - 오버라이딩한 String getGrade(int 점수)만 입력
  - PassFail 구현 클래스
    - 오버라이딩한 String getGrade(int 점수)만 입력
- Report sealed 추상 클래스 : 리포트에 관한 템플릿을 제공하는 추상 클래스. SubjectReport와 MajorReport 클래스만 상속을 허용함.
  - 필드: 자주 사용하는 기호들에 관한 것들 상수로 선언, Reportable 인터페이스, 학생 ArrayList, 최종 리포트, 헤더, 메인, 푸터
  - 생성자: Reportable을 상속받는 타입과 학생들(가변인자)을 입력해야하고 필요한 생성자와 템플릿 메서드 호출
  - 메서드: 헤더 생성, 메인 생성, 푸터 생성, 집계(총점, 최빈값, 최고점, 최저점, 평균, 인원) 메서드, 학생 목록 필터링(조건에 맞는 학생만), 최종 리포트를 만들기 위한 템플릿 메서드, 리포트 출력하는 메서드
  - Reportable 마커 인터페이스 : 리포트할 수 있는 것들을 제한하는 마커 인터페이스
  - MajorReport 구현 클래스 : 전공생에 대한 결과를 집계하는 리포트 클래스
    - 생성자와 리포트 결과 출력하는 메서드만 사용 가능
    - 생성자: 전공과 학생들(배열)을 입력하면 집계됨
    - 메서드: 학생 목록 필터링(해당 전공생만 ArrayList에 추가), 헤더 내용 생성, 메인 내용 생성, 푸터 내용 생성, sum(의미가 없는 것 같은데 오버라이딩해야해서 -1 반환하게 함), mode(학점 중 최빈값 반환 - 동일하면 앞에 있는 성적 출력), avg(학생 평균 점수 출력), max/min(학생 최고점/최저점 출력)
  - SubjectReport 구현 클래스 : 강의 수강생에 대한 결과를 집계하는 리포트 클래스
    - 생성자와 리포트 결과 출력하는 메서드만 사용 가능
    - 생성자: 과목과 학생들(가변인자)을 입력하면 집계됨
    - 메서드: 학생 목록 필터링(해당 과목을 듣는 학생만 ArrayList에 추가), 헤더 내용 생성, 메인 내용 생성, 푸터 내용 생성, sum(학생들의 점수 총합), mode(점수 시스템이 달라서 null 반환/사용하지 않음), avg(학생 점수 평균 산출), max/min(학생들 점수 중 최고점/최저점 산출)
- RunTest 실행 클래스
  - 강의 과목 생성
  - 전공 생성
  - 학생 생성
  - 수강과목 담기 및 점수 입력
  - 학생 목록 생성
  - 클래스 및 메서드 테스트용 출력들
  - 강의과목 리포트 생성
  - 전공 리포트 생성
- FinalStaticNumber 클래스 : 상수 영역(만들어놓고 사용할 일이 없어서 비워져있음)
- 기타 과정에 대한 것들 기록(https://blog.naver.com/biyoonx/223117795740)


# ChatProgram(TCP 소켓 프로그래밍을 이용한 채팅 프로그램)
- 책 <이것이 자바다>의 Chapter 19 Section 7의 채팅 프로그램 실습
- 설계의 틀은 책에서 가져왔으나 만들면서 내 방식대로 변형시켜본 것
- ChatServer 클래스 : 채팅프로그램의 유저(클라이언트)의 연결 요청을 승인하며 채팅방을 관리하는 클래스
  - 필드 : 서버 소켓, 스레드풀(SocketClient에서 사용), 유저(클라이언트)와 연결된 소켓을 관리하기 위한 동기화된 맵인 chatRoom(채팅방)
  - 메서드
    - start(int portNo) : 포트번호를 매개값으로 받아 이 포트로 서버 열기
    - run() : 유저와 연결을 승인(accept())하고 반환된 소켓을 SocketClient를 생성하여 매개값으로 넘김. SocketClient의 receive() 함수를 호출하여 유저의 요청에 따라 입장, 메세지 전송, 퇴장이 이루어질 수 있도록 함. 스레드를 별도로 생성하였기 때문에 서버 소켓이 닫히면 에러가 발생하므로 프로세스가 종료되도록 예외처리함. 데몬스레드로 설정하여 메인 스레드가 종료하면 해당 스레드도 종료되도록 함.
    - stop() : 서버 소켓을 닫고 스레드풀을 정리함. chatRoom에 있는 SocketClient의 소켓도 모두 닫도록 함.
    - addToChatRoom(SocketClient clientSoc) : 채팅방에 유저가 입장되도록 함(서버가 관리하는 목록에 추가)
    - removeFromChatRoom(SocketClient clientSoc) : 채팅방에 유저가 퇴장하도록 함(서버가 관리하는 목록에서 삭제)
    - private String notice(String status, String userInfo) : 유저가 채팅방에 입장 또는 퇴장시 알림으로 사용할 문자열 생성
    - sendToAll(SocketClient sender, String receivedMessage) : 유저가 요청 사항을 보내면 해당 내용이 발신자를 제외한 채팅방의 모든 유저에게 일괄 전송되도록 함(chatRoom으로 관리하는, 유저와 연결된 모든 소켓에서 데이터를 보내는 방식).
    - String mkMessage(String key, String receivedMessage) : 유저에게 메세지를 보낼때 형식을 JSON으로 바꿔주는 메서드
  - 스레드 : 메인 스레드와 채팅방에 딜레이 적게 유저를 받을 수 있도록 하기 위해 run() 부분 분리
  - 메인 메서드(실행)
    - 55555번 포트로 서버 오픈.
    - 유저의 연결 요청을 받는 스레드 따로 생성.
    - Scanner를 받아서 서버가 바로 종료되지 않도록 콘솔창에 stop을 입력받을 때까지 stop() 메서드 블로킹시킴
- SocketClient 클래스 : 서버가 채팅 유저와 연결된 소켓을 관리하기 위해 만든 클래스(서버에서 동기화된 맵으로 관리함), ChatServer의 내부 인스턴스 클래스로 만들어도 될 듯하나 너무 길어져서 분리한 듯 main() 메서드는 없는데 이는 채팅 서버의 run()에서 생성하고 모든 프로세스가 돌아가게 하는 receive()가 호출되었기 때문.
  - 필드 : 서버 소켓, 유저와 연결된 소켓, 유저의 key(채팅명@클라이언트 IP 또는 HostName), DataInputStream, DataOutputStream, 클라이언트의 주소 정보(IP 또는 HostName), 조용히 퇴장 여부
  - 생성자 : 서버 소켓과 유저와 연결된 매개값을 받아 내부 멤버변수에 넣어줌. 입출력스트림을 유저와 연결된 소켓과 연결.
  - 메서드
    - send() : 소켓에 연결된 유저에게 매개값으로 입력된 메세지 전송(출력 스트림 사용)
    - receive()
      - 입력 스트림으로 유저에게 요청 메세지를 받아 JSONObject로 메세지 파싱.
        - 메세지(msg) : 키 request의 값이 msg이면 키 data로 온 메세지 msg 내용을 전송
        - 입장(entry) : 키 request의 값이 entry이면 유저의 key(채팅명@IP 또는 HostName)를 설정하고 채팅방에 입장하도록 함. 입장한 유저를 제외한 모든 방에 입장했다는 메세지 전송.
        - 조용히 퇴장(quietExit) : 키 request의 값이 quietExit이면 조용히 퇴장 여부를 data값(true)으로 변경. (퇴장은 후에 유저가 소켓을 닫으면 예외로 넘어가서 처리됨)
        - 예외(퇴장) : 채팅방에서 유저를 제외하고 유저와 연결된 소켓을 닫음. 조용히 퇴장 여부가 false일 경우만 모든 방에 퇴장 메세지가 전송됨(true면 전송되지 않음)
    - close() : 서버의 chatRoom에서 해당 소켓을 제거(=채팅방 퇴장)하고 유저와 연결된 소켓을 닫음.
    - 기타 getter/setter : String getKey(), String getAddrInfo(), setKey(String chatName), setAddrInfo(String hostString), setQuietExit(boolean quietExit)
  - 스레드 : 유저의 요청을 처리하기 위해 스레드풀 사용. 유저들의 입장/퇴장과 메세지 전송에 따라 동시다발적으로 많은 요청이 있을 수 있기 때문에 스레드풀로 스레드 생성.
- ChatUser 클래스 : 유저용 소켓을 생성하고 서버 및 다른 사용자와 소통할 수 있는 클래스(클래스 이름을 책에 있는 ChatClient로 하면 헷갈려서 ChatUser로 변경함)
  - 필드 : 서버와 연결된 소켓, 데이터 입출력 스트림, 채팅명
  - 메서드
    - connect(String addr, int portNo) : 연결할 서버의 IP 주소와 포트번호를 매개값으로 받아 해당 서버로 연결함. 입출력 스트림을 서버와 연결된 소켓에 연결함.
    - unconnect() : 서버와 연결된 소켓을 닫음. (서버에서 퇴장 처리됨)
    - setChatName(String chatName) : 채팅명을 설정함.
    - send(String message) : 서버와 통신하기 위한 메서드로 서버에 요청내용을 매개변수로 받아 "전송"하는 역할.(전송만 함)
      - String mkRequest(String request, String data) : 서버에 요청할 메세지 내용을 JSON 형태로 생성(매개값으로 넘길 문자열)
      - enterChatRoom() : 서버에 채팅방에 입장하겠다는 요청 전송
      - exitChatRoom(boolean quietExit) : 매개값으로 조용히 퇴장 여부를 받아 true일 경우 서버에 조용히 퇴장 여부의 값을 전송함. (서버와 연결은 끊지 않고 이 메서드 호출 후 unconnect() 메서드로 연결 해제. 다만 채팅방에 퇴장 알림은 조용히 퇴장 여부에 따라서 띄움. 메서드명이 적절치 않은 것 같아 unconnect()를 호출할지 메서드명을 바꿀지 고민했다가 메서드명을 바꾸는게 낫다고 생각했으나 적절한 이름을 생각하지 못함.)
      - sendMessage(String message) : 채팅방에 메시지를 전송하는 메서드
    - receive() : 서버로부터 메세지를 받아서 파싱하고 유저에게 띄우는 메서드. 메세지 전송과 수신을 동시에 하기 위해 스레드를 생성. 메인 메서드가 종료되면 함께 종료되도록 데몬 스레드로 설정. 서버와 연결을 끊겨 예외가 발생했을 경우 프로세스를 종료시킴.
  - 스레드 : 서버로부터 데이터를 수신하는 메서드를 메세지 발신과 동시에 실행될 수 있도록 receive() 메서드에 스레드를 생성하여 분리하였음.
  - 메인 메서드(실행)
    - 포트번호 55555로 "localhost"에 열린 서버와 연결.
    - Scanner을 생성하여 유저가 대화명을 입력하도록 하여 chatName에 저장한 후 채팅방 입장.
    - receive()를 호출(스레드가 별도로 생성됨)
    - 유저로부터 (콘솔창에서) 메세지를 입력받아서 메세지 전송.
    - exit만 입력했을 경우 채팅모드를 종료하고 조용히 퇴장 여부 확인. y 입력시 조용히 퇴장, n 입력시 일반 퇴장, 기타 다른 것들을 입력했을 경우 퇴장을 취소하고 채팅모드로 돌아감.
    - 퇴장을 선택하였을 경우 Scanner를 닫고 서버와 연결을 끊음.
- 기타 과정에 대한 것들 기록(https://blog.naver.com/biyoonx/223122712567)


# JS Validation API
- 과제로 받았던 것을 좀 더 발전시켜서 Web API를 적용해본 것
- HTML : 아이디, 비밀번호, 비밀번호 확인, 이름 칸과 회원가입 버튼으로 이루어진 구조
- CSS : 기능 구현 중심으로 하였기 때문에 스타일상의 특이사항은 없다. 다만 다른 블로그를 참고하여 :invalid를 추가하였는데 유효하지 않을 때 스타일이 바로 적용되는 것이 아니라 회원가입 버튼을 적어도 한번은 눌러야 스타일이 적용되도록 되어 있다.
- JS
  - 구조는 먼저 공통적으로 사용하는 값(유효성 상태, 유효성 검사 결과 메세지)를 모아두었고, 그 값들을 변경할 수 있는 메서드(원할 때마다 유효성 검사를 해서 결과값을 가져다 쓸수 있게 하기 위함)도 함께 만들었다.
  - 회원가입 버튼과 무관하게 실시간으로 동작하는 유효성 검사
    - 사용자가 값을 입력했을 때 아이디(임의의 값)의 중복을 체크하거나 비밀번호와 비밀번호 확인의 값들이 일치하는지 여부를 확인해서 밑에 문구가 추가되는 이벤트의 함수를 단계적으로 나누어 만들었다. 이는 사용자가 값을 입력할 때마다 실시간으로 확인된다.
    - 아이디와 비밀번호 확인칸에 조건에 따라 이벤트를 입력해주었고 비밀번호 확인칸의 이벤트는 너무 길어져서 함수로 만들어주었다.
  - 회원가입 버튼을 클릭한 후 유효성 검사
    - 회원가입 버튼을 누르고 나서는 일단 유효성 검사가 수행되었다는 마커 역할을 하는 클래스를 각 칸들에 넣어주었고 유효성 검사를 수행한다. 유효성 검사에 통과하지 못하면 검사를 멈추고 사용자에게 그 이유를 알려주는 알림을 띄운다. Validation API를 활용해서 커스텀 메세지를 띄우는 방법을 사용하였으나 브라우저 툴팁을 중단시키고 alert를 이용하는 방법도 만들어두었다(주석처리 되어있음). 유효성 검사는 모두 동일한 함수로 동작하는데 체크하고자 하는 유효성 타입을 받아서 상태를 확인하고 만약 유효하지 않을 경우 알림을 띄우는 함수와 이 때 사용할 메세지를 불러오는 함수를 만들어 두어 유효성 검사가 되도록 일괄적으로, 동일한 형태로 동작하도록 만들어주었다.
- 기타 과정에 대한 것들 기록(https://blog.naver.com/biyoonx/223140316672)


# SimpleBulletinBoard
- 과제로 받았던 것을 좀 더 발전시켜서 단순 구현이 아니라 진짜 간이 게시판으로 기능할 수 있도록 여러 기능을 추가해본 것
- 기타 과정에 대한 것들 기록(https://blog.naver.com/biyoonx/223139630336)
